From 7eaa671e88a0636eacffb60db2944a75e3532284 Mon Sep 17 00:00:00 2001
From: jrmarino <draco@marino.st>
Date: Wed, 17 May 2017 22:23:51 -0500
Subject: [PATCH] Another follow-up for issue #1431

The initial problem started with commit 4d53b1 which added the
AT_SYMLINK_NOFOLLOW flag to fchmodat function.  On Linux, the flag is
recognized but not implemented.  Setting the flag on Linux causes
ENOTSUP to return in every case, which issue #1431 reported.

The solution to add a second "fallback" attempt by calling fchmodat was
accepted, but I think it was not tested on a port that contained
symbolic links in the packing list.  It doesn't work for symbolic links.
fchmodat will follow the link and fail with ENOENT (file not found).
From my limited research, it's not possible to change file modes on
symbolic links on Linux -- not until AT_SYMLINK_NOFOLLOW is implemented.
Note that lchmod is not an option because it has not been implemented
on Linux, nor is it part of the POSIX standard.

Thus this modification which is only seen by platforms that don't
support AT_SYMLINK_NOFOLLOW (which excludes FreeBSD, DragonFly and
NetBSD but includes Linux) now skips symbolic links as the attempt to
change file mode is impossible and fatal.  This is okay because the
permissions of symlinks have never been evaluated; they are taken from
the target of the link.  Thus changing permissions of symlinks is
cosmetic and the impact of not modifying them is nil in all cases.
---
 libpkg/pkg_add.c | 22 +++++++++++++++++++---
 1 file changed, 19 insertions(+), 3 deletions(-)

diff --git libpkg/pkg_add.c b/libpkg/pkg_add.c
index 7c8f9b2fe..a2cb5733f 100644
--- libpkg/pkg_add.c
+++ libpkg/pkg_add.c
@@ -228,6 +228,7 @@ set_attrs(int fd, char *path, mode_t perm, uid_t uid, gid_t gid,
 {
 
 	struct timeval tv[2];
+	struct stat st;
 	int fdcwd;
 #ifdef HAVE_UTIMENSAT
 	struct timespec times[2];
@@ -285,9 +286,24 @@ set_attrs(int fd, char *path, mode_t perm, uid_t uid, gid_t gid,
 	/* zfs drops the setuid on fchownat */
 	if (fchmodat(fd, RELATIVE_PATH(path), perm, AT_SYMLINK_NOFOLLOW) == -1) {
 		if (errno == ENOTSUP) {
-			if (fchmodat(fd, RELATIVE_PATH(path), perm, 0) == -1) {
-				pkg_fatal_errno("Fail to chmod(fallback) %s",
-				    path);
+			/* 
+			 * Executing fchmodat on a symbolic link results in
+			 * ENOENT (file not found) on platforms that do not
+			 * support AT_SYMLINK_NOFOLLOW. The file mode of
+			 * symlinks cannot be modified via file descriptor
+			 * reference on these systems. The lchmod function is
+			 * also not an option because it is not a posix
+			 * standard, nor is implemented everywhere. Since
+			 * symlink permissions have never been evaluated and
+			 * thus cosmetic, just skip them on these systems.
+			 */
+			if (fstatat(fd, RELATIVE_PATH(path), &st, AT_SYMLINK_NOFOLLOW) == -1) {
+				pkg_fatal_errno("Fail to get file status %s", path);
+			}
+			if (!S_ISLNK(st.st_mode)) {
+				if (fchmodat(fd, RELATIVE_PATH(path), perm, 0) == -1) {
+					pkg_fatal_errno("Fail to chmod(fallback) %s", path);
+				}
 			}
 		}
 		else {
