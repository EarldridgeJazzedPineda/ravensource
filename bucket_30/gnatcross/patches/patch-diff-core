--- gcc/config/dragonfly.h.orig
+++ gcc/config/dragonfly.h
@@ -84,13 +84,13 @@
    } \
    %{static:-Bstatic} \
   } \
-  %{!static:--hash-style=gnu} \
+  %{!static:--hash-style=gnu --enable-new-dtags -rpath @PREFIX@/lib} \
   %{symbolic:-Bsymbolic}"
 
 #undef  LINK_SPEC
 #define LINK_SPEC DFBSD_LINK_SPEC
 
-#define DFBSD_DYNAMIC_LINKER "/usr/libexec/ld-elf.so.2"
+#define DFBSD_DYNAMIC_LINKER "/libexec/ld-elf.so.2"
 
 
 /* Use --as-needed -lgcc_s for eh support.  */
--- gcc/config/sol2.h.orig
+++ gcc/config/sol2.h
@@ -354,6 +354,7 @@
    %{static:-dn -Bstatic} \
    %{shared:-G -dy %{!mimpure-text:-z text}} " \
    LINK_LIBGCC_MAPFILE_SPEC LINK_CLEARCAP_SPEC " \
+   %{!static:-R/lib/amd64:@PREFIX@/lib/amd64} \
    %{symbolic:-Bsymbolic -G -dy -z text} \
    %(link_arch) \
    %{Qy:} %{!Qn:-Qy}"
--- gcc/config/aarch64/aarch64-freebsd.h.orig
+++ gcc/config/aarch64/aarch64-freebsd.h
@@ -41,6 +41,7 @@
     %{symbolic:-Bsymbolic}                                      \
     %{static:-Bstatic}                                          \
     %{!static:                                                  \
+    %{!static:--hash-style=gnu --enable-new-dtags -rpath @PREFIX@/lib}   \
       %{rdynamic:-export-dynamic}                               \
       %{!shared:-dynamic-linker " FBSD_DYNAMIC_LINKER " }}      \
     -X" SUBTARGET_EXTRA_LINK_SPEC "                             \
@@ -99,4 +100,6 @@
 #undef MCOUNT_NAME
 #define MCOUNT_NAME ".mcount"
 
+/* Static stack checking is supported by means of probes.  */
+#define STACK_CHECK_STATIC_BUILTIN 1
 #endif  /* GCC_AARCH64_FREEBSD_H */
--- gcc/config/i386/freebsd.h.orig
+++ gcc/config/i386/freebsd.h
@@ -88,6 +88,7 @@
         %{rdynamic:-export-dynamic} \
         -dynamic-linker %(fbsd_dynamic_linker) } \
     %{static:-Bstatic}} \
+  %{!static:--hash-style=gnu --enable-new-dtags -rpath @PREFIX@/lib} \
   %{symbolic:-Bsymbolic}"
 
 /* A C statement to output to the stdio stream FILE an assembler
--- gcc/config/i386/freebsd64.h.orig
+++ gcc/config/i386/freebsd64.h
@@ -41,4 +41,5 @@
         %{rdynamic:-export-dynamic} \
 	-dynamic-linker %(fbsd_dynamic_linker) } \
     %{static:-Bstatic}} \
+  %{!static:--hash-style=gnu -rpath @PREFIX@/lib} \
   %{symbolic:-Bsymbolic}"
--- gcc/Makefile.in.orig
+++ gcc/Makefile.in
@@ -1200,7 +1200,6 @@
 	insn-emit.o \
 	insn-extract.o \
 	insn-latencytab.o \
-	insn-modes.o \
 	insn-opinit.o \
 	insn-output.o \
 	insn-peep.o \
@@ -1597,6 +1596,7 @@
   $(OBJS-libcommon-target) main.o c-family/cppspec.o \
   $(COLLECT2_OBJS) $(EXTRA_GCC_OBJS) $(GCOV_OBJS) $(GCOV_DUMP_OBJS) \
   $(GCOV_TOOL_OBJS) $(GENGTYPE_OBJS) gcc-ar.o gcc-nm.o gcc-ranlib.o \
+  insn-modes.o insn-modes-ada.o \
   lto-wrapper.o collect-utils.o
 
 # for anything that is shared use the cc1plus profile data, as that
@@ -1612,6 +1612,11 @@
 ALL_HOST_OBJS = $(ALL_HOST_FRONTEND_OBJS) $(ALL_HOST_BACKEND_OBJS)
 
 BACKEND = libbackend.a main.o libcommon-target.a libcommon.a \
+	insn-modes.o \
+	$(CPPLIB) $(LIBDECNUMBER)
+
+BACKEND2 = libbackend.a main.o libcommon-target.a libcommon.a \
+	insn-modes-ada.o \
 	$(CPPLIB) $(LIBDECNUMBER)
 
 # This is defined to "yes" if Tree checking is enabled, which roughly means
@@ -2312,6 +2317,7 @@
 
 insn-modes.c: s-modes; @true
 insn-modes.h: s-modes-h; @true
+insn-modes-ada.c: s-modes-ada; @true
 min-insn-modes.c: s-modes-m; @true
 
 s-modes: build/genmodes$(build_exeext)
@@ -2329,6 +2335,12 @@
 	$(SHELL) $(srcdir)/../move-if-change tmp-min-modes.c min-insn-modes.c
 	$(STAMP) s-modes-m
 
+s-modes-ada: s-modes
+	$(shell sed -e 's/: TARGET_96_ROUND_53_LONG_DOUBLE \? &ieee_extended_intel_96_round_53_format //' \
+		< insn-modes.c > tmp-modes-ada.c)
+	$(SHELL) $(srcdir)/../move-if-change tmp-modes-ada.c insn-modes-ada.c
+	$(STAMP) s-modes-ada
+
 insn-preds.c: s-preds; @true
 tm-preds.h: s-preds-h; @true
 tm-constrs.h: s-constrs-h; @true
@@ -3536,6 +3548,9 @@
 	    ( cd $(DESTDIR)$(bindir) && \
 	      $(LN) $(GCC_INSTALL_NAME)$(exeext) $(FULL_DRIVER_NAME) ); \
 	  fi; \
+	  if [ -f gnat1$(exeext) ] ; then \
+	    ( cd $(DESTDIR)$(bindir) && $(LN) $(GCC_INSTALL_NAME)$(exeext) ada$(exeext) ) \
+	  fi; \
 	  if [ ! -f gcc-cross$(exeext) ] \
 	      && [ "$(GCC_INSTALL_NAME)" != "$(GCC_TARGET_INSTALL_NAME)" ]; then \
 	    rm -f $(DESTDIR)$(bindir)/$(target_noncanonical)-gcc-tmp$(exeext); \
--- gcc/config/i386/gnu-user64.h.orig
+++ gcc/config/i386/gnu-user64.h
@@ -57,6 +57,7 @@
                    %{" SPEC_32 ":-m " GNU_USER_LINK_EMULATION32 "} \
                    %{" SPEC_X32 ":-m " GNU_USER_LINK_EMULATIONX32 "} \
   %{shared:-shared} \
+  %{!static:--enable-new-dtags -rpath @PREFIX@/lib64} \
   %{!shared: \
     %{!static: \
       %{rdynamic:-export-dynamic} \
--- gcc/dwarf2out.c.orig
+++ gcc/dwarf2out.c
@@ -12514,6 +12514,15 @@
 
       if (qualified_type == dtype)
 	{
+	  tree origin = decl_ultimate_origin (name);
+
+	  /* Typedef variants that have an abstract origin don't get their own
+	     type DIE (see gen_typedef_die), so fall back on the ultimate
+	     abstract origin instead.  */
+	  if (origin != NULL)
+	    return modified_type_die (TREE_TYPE (origin), cv_quals, reverse,
+				      context_die);
+
 	  /* For a named type, use the typedef.  */
 	  gen_type_die (qualified_type, context_die);
 	  return lookup_type_die (qualified_type);
@@ -24346,7 +24355,7 @@
 gen_typedef_die (tree decl, dw_die_ref context_die)
 {
   dw_die_ref type_die;
-  tree origin;
+  tree type;
 
   if (TREE_ASM_WRITTEN (decl))
     {
@@ -24355,75 +24364,71 @@
       return;
     }
 
+  /* As we avoid creating DIEs for local typedefs (see decl_ultimate_origin
+     checks in process_scope_var and modified_type_die), this should be called
+     only for original types.  */
+  gcc_assert (decl_ultimate_origin (decl) == NULL);
+
   TREE_ASM_WRITTEN (decl) = 1;
   type_die = new_die (DW_TAG_typedef, context_die, decl);
-  origin = decl_ultimate_origin (decl);
-  if (origin != NULL)
-    add_abstract_origin_attribute (type_die, origin);
-  else
+
+  add_name_and_src_coords_attributes (type_die, decl);
+  if (DECL_ORIGINAL_TYPE (decl))
     {
-      tree type = TREE_TYPE (decl);
+      type = DECL_ORIGINAL_TYPE (decl);
+      if (type == error_mark_node)
+	return;
 
+      gcc_assert (type != TREE_TYPE (decl));
+      equate_type_number_to_die (TREE_TYPE (decl), type_die);
+    }
+  else
+    {
+      type = TREE_TYPE (decl);
       if (type == error_mark_node)
 	return;
 
-      add_name_and_src_coords_attributes (type_die, decl);
-      if (DECL_ORIGINAL_TYPE (decl))
+      if (is_naming_typedef_decl (TYPE_NAME (type)))
 	{
-	  type = DECL_ORIGINAL_TYPE (decl);
-
-	  if (type == error_mark_node)
-	    return;
-
-	  gcc_assert (type != TREE_TYPE (decl));
-	  equate_type_number_to_die (TREE_TYPE (decl), type_die);
+	  /* Here, we are in the case of decl being a typedef naming
+	     an anonymous type, e.g:
+		 typedef struct {...} foo;
+	     In that case TREE_TYPE (decl) is not a typedef variant
+	     type and TYPE_NAME of the anonymous type is set to the
+	     TYPE_DECL of the typedef. This construct is emitted by
+	     the C++ FE.
+
+	     TYPE is the anonymous struct named by the typedef
+	     DECL. As we need the DW_AT_type attribute of the
+	     DW_TAG_typedef to point to the DIE of TYPE, let's
+	     generate that DIE right away. add_type_attribute
+	     called below will then pick (via lookup_type_die) that
+	     anonymous struct DIE.  */
+	  if (!TREE_ASM_WRITTEN (type))
+	    gen_tagged_type_die (type, context_die, DINFO_USAGE_DIR_USE);
+
+	  /* This is a GNU Extension.  We are adding a
+	     DW_AT_linkage_name attribute to the DIE of the
+	     anonymous struct TYPE.  The value of that attribute
+	     is the name of the typedef decl naming the anonymous
+	     struct.  This greatly eases the work of consumers of
+	     this debug info.  */
+	  add_linkage_name_raw (lookup_type_die (type), decl);
 	}
-      else
-	{
-	  if (is_naming_typedef_decl (TYPE_NAME (type)))
-	    {
-	      /* Here, we are in the case of decl being a typedef naming
-	         an anonymous type, e.g:
-	             typedef struct {...} foo;
-	         In that case TREE_TYPE (decl) is not a typedef variant
-	         type and TYPE_NAME of the anonymous type is set to the
-	         TYPE_DECL of the typedef. This construct is emitted by
-	         the C++ FE.
-
-	         TYPE is the anonymous struct named by the typedef
-	         DECL. As we need the DW_AT_type attribute of the
-	         DW_TAG_typedef to point to the DIE of TYPE, let's
-	         generate that DIE right away. add_type_attribute
-	         called below will then pick (via lookup_type_die) that
-	         anonymous struct DIE.  */
-	      if (!TREE_ASM_WRITTEN (type))
-	        gen_tagged_type_die (type, context_die, DINFO_USAGE_DIR_USE);
-
-	      /* This is a GNU Extension.  We are adding a
-		 DW_AT_linkage_name attribute to the DIE of the
-		 anonymous struct TYPE.  The value of that attribute
-		 is the name of the typedef decl naming the anonymous
-		 struct.  This greatly eases the work of consumers of
-		 this debug info.  */
-	      add_linkage_name_raw (lookup_type_die (type), decl);
-	    }
-	}
-
-      add_type_attribute (type_die, type, decl_quals (decl), false,
-			  context_die);
+    }
 
-      if (is_naming_typedef_decl (decl))
-	/* We want that all subsequent calls to lookup_type_die with
-	   TYPE in argument yield the DW_TAG_typedef we have just
-	   created.  */
-	equate_type_number_to_die (type, type_die);
+  add_type_attribute (type_die, type, decl_quals (decl), false,
+		      context_die);
 
-      type = TREE_TYPE (decl);
+  if (is_naming_typedef_decl (decl))
+    /* We want that all subsequent calls to lookup_type_die with
+       TYPE in argument yield the DW_TAG_typedef we have just
+       created.  */
+    equate_type_number_to_die (type, type_die);
 
-      add_alignment_attribute (type_die, type);
+  add_alignment_attribute (type_die, TREE_TYPE (decl));
 
-      add_accessibility_attribute (type_die, decl);
-    }
+  add_accessibility_attribute (type_die, decl);
 
   if (DECL_ABSTRACT_P (decl))
     equate_decl_number_to_die (decl, type_die);
@@ -24535,15 +24540,23 @@
       if (TREE_ASM_WRITTEN (type))
 	return;
 
+      tree name = TYPE_NAME (type);
+      tree origin = decl_ultimate_origin (name);
+      if (origin != NULL)
+	{
+	  gen_decl_die (origin, NULL, NULL, context_die);
+	  return;
+	}
+
       /* Prevent broken recursion; we can't hand off to the same type.  */
-      gcc_assert (DECL_ORIGINAL_TYPE (TYPE_NAME (type)) != type);
+      gcc_assert (DECL_ORIGINAL_TYPE (name) != type);
 
       /* Give typedefs the right scope.  */
       context_die = scope_die_for (type, context_die);
 
       TREE_ASM_WRITTEN (type) = 1;
 
-      gen_decl_die (TYPE_NAME (type), NULL, NULL, context_die);
+      gen_decl_die (name, NULL, NULL, context_die);
       return;
     }
 
@@ -24862,6 +24875,22 @@
   else
     die = NULL;
 
+  /* Avoid creating DIEs for local typedefs and concrete static variables that
+     will only be pruned later.  */
+  if ((origin || decl_ultimate_origin (decl))
+      && (TREE_CODE (decl_or_origin) == TYPE_DECL
+	  || (VAR_P (decl_or_origin) && TREE_STATIC (decl_or_origin))))
+    {
+      origin = decl_ultimate_origin (decl_or_origin);
+      if (decl && VAR_P (decl) && die != NULL)
+	{
+	  die = lookup_decl_die (origin);
+	  if (die != NULL)
+	    equate_decl_number_to_die (decl, die);
+	}
+      return;
+    }
+
   if (die != NULL && die->die_parent == NULL)
     add_child_die (context_die, die);
   else if (TREE_CODE (decl_or_origin) == IMPORTED_DECL)
